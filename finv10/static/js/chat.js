document.addEventListener('DOMContentLoaded', () => { const socket = io(); const roomName = ROOM_NAME; const messagesContainer = document.getElementById('messages'); const messageForm = document.getElementById('message-form'); const messageInput = document.getElementById('message-input'); const analyzeBtn = document.getElementById('analyze-trends-btn'); const trendResultsDiv = document.getElementById('trend-results'); const trendSelector = document.getElementById('trend-selector'); const modelSelector = document.getElementById('model-selector'); const daysInput = document.getElementById('days-input'); const predictBtn = document.getElementById('predict-btn'); const chartCanvas = document.getElementById('trend-chart'); let trendChart; socket.on('connect', () => socket.emit('join', { room: roomName })); socket.on('status', data => addMessage(data.msg, 'status')); socket.on('receive_message', data => addMessage(data.msg, 'user', data.user)); messageForm.addEventListener('submit', e => { e.preventDefault(); const message = messageInput.value.trim(); if (message) { socket.emit('send_message', { room: roomName, message }); messageInput.value = ''; } }); function addMessage(msg, type, user = '') { const div = document.createElement('div'); if (type === 'user') { div.className = 'message'; div.innerHTML = `<span class="username">${user}:</span><span class="content">${msg}</span>`; } else { div.className = 'status-text'; div.textContent = msg; } messagesContainer.appendChild(div); messagesContainer.scrollTop = messagesContainer.scrollHeight; } analyzeBtn.addEventListener('click', async () => { trendResultsDiv.innerHTML = '<p class="placeholder">Analyzing... this may take a moment.</p>'; analyzeBtn.disabled = true; const response = await fetch(`/api/trends/${roomName}`); const data = await response.json(); if (data.error) { trendResultsDiv.innerHTML = `<p class="placeholder" style="color: #f87171;">Error: ${data.error}</p>`; analyzeBtn.disabled = false; return; } displayTrendResults(data); populateTrendSelector(data.what_is_going_on); analyzeBtn.disabled = false; }); function displayTrendResults(data) { let html = `<div class="viral-trend"><strong>Most Infectious Trend:</strong><p>${data.most_infectious_trend}</p></div><strong>Topics Discovered:</strong><ul class="topic-list">`; data.what_is_going_on.forEach(topic => { html += `<li><strong>Topic ${topic.id}:</strong> ${topic.keywords}</li>`; }); html += '</ul>'; trendResultsDiv.innerHTML = html; } function populateTrendSelector(topics) { trendSelector.innerHTML = ''; topics.forEach(topic => { const option = document.createElement('option'); option.value = topic.id; option.textContent = `Topic ${topic.id}: ${topic.keywords}`; trendSelector.appendChild(option); }); trendSelector.disabled = false; modelSelector.disabled = false; daysInput.disabled = false; predictBtn.disabled = false; } predictBtn.addEventListener('click', async () => { const topicId = parseInt(trendSelector.value); const days = parseInt(daysInput.value); const model = modelSelector.value; if (isNaN(topicId) || isNaN(days)) return; predictBtn.textContent = 'Predicting...'; predictBtn.disabled = true; const response = await fetch(`/api/predict_trend/${roomName}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ topic_id: topicId, days: days, model: model }) }); const data = await response.json(); if (data.error) { alert(`Prediction Error: ${data.error}`); } else { updateChart(data.predictions); } predictBtn.textContent = 'Predict'; predictBtn.disabled = false; }); function initializeChart() { const ctx = chartCanvas.getContext('2d'); trendChart = new Chart(ctx, { type: 'line', data: { labels: [], datasets: [ { label: 'Susceptible', data: [], borderColor: '#38BDF8', tension: 0.3, pointBackgroundColor: '#38BDF8' }, { label: 'Infected', data: [], borderColor: '#F471B5', tension: 0.3, pointBackgroundColor: '#F471B5' }, { label: 'Recovered', data: [], borderColor: '#6B7280', tension: 0.3, pointBackgroundColor: '#6B7280' } ]}, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: 'white' }}}, scales: { x: { ticks: { color: 'white' }}, y: { ticks: { color: 'white' }} }} }); } function updateChart(predictions) { trendChart.data.labels = []; trendChart.data.datasets.forEach((dataset) => { dataset.data = []; }); trendChart.data.labels = Array.from({ length: predictions.length }, (_, i) => `Day ${i + 1}`); trendChart.data.datasets[0].data = predictions.map(p => p[0]); trendChart.data.datasets[1].data = predictions.map(p => p[1]); trendChart.data.datasets[2].data = predictions.map(p => p[2]); trendChart.update(); } initializeChart(); });